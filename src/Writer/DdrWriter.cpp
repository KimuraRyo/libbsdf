// =================================================================== //
// Copyright (C) 2014-2015 Kimura Ryo                                  //
//                                                                     //
// This Source Code Form is subject to the terms of the Mozilla Public //
// License, v. 2.0. If a copy of the MPL was not distributed with this //
// file, You can obtain one at http://mozilla.org/MPL/2.0/.            //
// =================================================================== //

#include <libbsdf/Writer/DdrWriter.h>

#include <fstream>
#include <iostream>

#include <libbsdf/Common/SpectrumUtility.h>
#include <libbsdf/Common/Version.h>

using namespace lb;

bool DdrWriter::write(const std::string& fileName, const SpecularCoordinatesBrdf& brdf)
{
    std::ofstream fout(fileName.c_str());
    if (fout.fail()) {
        std::cerr << "[DdrReader::write] Could not open: " << fileName << std::endl;
        return false;
    }

    fout << ";; This file is generated by libbsdf-" << getVersion() << ".\n" << std::endl;

    const SampleSet* ss = brdf.getSampleSet();

    ColorModel colorModel;

    fout << "Source Measured" << std::endl;
    fout << "TypeSym ASymmetrical" << std::endl;

    fout << "TypeColorModel ";
    if (ss->getNumWavelengths() == 1) {
        colorModel = MONOCHROMATIC_MODEL;
        fout << "BW" << std::endl;
    }
    else if (ss->getColorModel() == RGB_MODEL ||
             ss->getColorModel() == XYZ_MODEL) {
        colorModel = RGB_MODEL;
        fout << "RGB" << std::endl;
    }
    else {
        colorModel = SPECTRAL_MODEL;
        fout << "spectral " << ss->getNumWavelengths() << std::endl;
    }

    fout << "TypeData Luminance Absolute" << std::endl;

    fout << "sigma " << brdf.getNumInTheta() << std::endl;
    for (int i = 0; i < brdf.getNumInTheta(); ++i) {
        fout << " " << toDegree(brdf.getInTheta(i));
    }
    fout << std::endl;

    fout << "phi " << brdf.getNumSpecPhi() << std::endl;
    for (int i = 0; i < brdf.getNumSpecPhi(); ++i) {
        fout << " " << toDegree(brdf.getSpecPhi(i));
    }
    fout << std::endl;

    fout << "theta " << brdf.getNumSpecTheta() << std::endl;
    for (int i = 0; i < brdf.getNumSpecTheta(); ++i) {
        fout << " " << toDegree(brdf.getSpecTheta(i));
    }
    fout << std::endl;

    for (int wlIndex = 0; wlIndex < ss->getNumWavelengths(); ++wlIndex) {
        if (colorModel == MONOCHROMATIC_MODEL) {
            fout << "bw" << std::endl;
        }
        else if (colorModel == RGB_MODEL) {
            if (wlIndex == 0) {
                fout << "red" << std::endl;
            }
            else if (wlIndex == 1) {
                fout << "gre" << std::endl;
            }
            else {
                fout << "blu" << std::endl;
            }
        }
        else
        {
            fout << "wl " << ss->getWavelength(wlIndex) << std::endl;
        }

        fout << " kbdf" << std::endl;
        fout << " ";
        for (int i = 0; i < brdf.getNumInTheta(); ++i) {
            fout << " 1.0";
        }

        fout << "\n def" << std::endl;

        for (int inPhIndex = 0; inPhIndex < brdf.getNumInPhi(); ++inPhIndex) {
            fout << ";; Psi = " << toDegree(brdf.getInPhi(inPhIndex)) << std::endl;

            for (int inThIndex = 0; inThIndex < brdf.getNumInTheta(); ++inThIndex) {
                fout << ";; Sigma = " << toDegree(brdf.getInTheta(inThIndex)) << std::endl;

                for (int spPhIndex = 0; spPhIndex < brdf.getNumSpecPhi(); ++spPhIndex) {
                    for (int spThIndex = 0; spThIndex < brdf.getNumSpecTheta(); ++spThIndex) {
                        const Spectrum& sp = brdf.getSpectrum(inThIndex, inPhIndex, spThIndex, spPhIndex);

                        if (ss->getColorModel() == XYZ_MODEL) {
                            Spectrum rgb = SpectrumUtility::xyzToSrgb(sp);
                            fout << " " << rgb[wlIndex] * PI_F;
                        }
                        else {
                            fout << " " << sp[wlIndex] * PI_F;
                        }
                    }

                    fout << std::endl;
                }
            }
        }

        fout << " enddef" << std::endl;
    }

    return true;
}
